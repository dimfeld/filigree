use error_stack::{Report, ResultExt};
use filigree::{
    auth::ObjectPermission,
    errors::OrderByError,
    sql::{BindingOperator, WhereBuilder}
};
use serde::{Serialize, Deserialize};
use sqlx::PgPool;
use thiserror::Error;

use super::{{id_type}};
use super::types::*;

use crate::auth::AuthInfo;
use crate::Error;

/// Get an object and all its fields. This can be useful for internal operations when the object
/// should not be returned to the user.
pub async fn get_with_all_fields(db: &PgPool, auth: &AuthInfo, id: {{id_type}}) -> Result<{{ struct_base }}, Report<Error>> {
    let object = query_file_as!({{struct_base}}, "{{dir}}/select_one_all_fields.sql",
        id.as_uuid(),
        auth.org_id.as_uuid(),
        &auth.actor_ids
        )
        .fetch_optional(db)
        .await
        .change_context(Error::Db)?
        .ok_or_else(Error::NotFound("{{model_name}}"))?;

    Ok(object)

}

/// Get an object and coerce it to the owner or user view depending on the user's permissions.
pub async fn get(db: &PgPool, auth: &AuthInfo, id: {{id_type}}) -> Result<{{ struct_base }}FilteredView, Report<Error>> {
    let object = query_file_as!({{struct_base}}OwnerView, "{{dir}}/select_one.sql",
        id.as_uuid(),
        auth.org_id.as_uuid(),
        &auth.actor_ids
        )
        .map({{struct_base}}FilteredView::from_item)
        .fetch_optional(db)
        .await
        .change_context(Error::Db)?
        .ok_or_else(Error::NotFound("{{model_name}}"))?;

    Ok(object)
}

#[derive(Debug, Default)]
enum OrderByField {
    {% for field in fields  %}
    {% if field.sortable != "none" %}
        {% if field.snake_case_name == default_sort_field -%}
        #[default]
        {%- endif %}
    {{field.pascal_case_name}},
    {% endif %}
    {% endfor %}
}

impl OrderByField {
    fn as_str(&self) -> &str {
        match self {
            {% for field in fields  %}
            {% if field.sortable != "none" %}
            Self::{{field.pascal_case_name}} => "{{field.snake_case_name}}",
            {% endif %}
            {% endfor %}
        }
    }

    fn allowed_direction(&self, descending: bool) -> bool {
        match self {
            {% for field in fields | filter(attribute="sortable", value="ascending_only") %}
            Self::{{field.pascal_case_name}} => descending == false,
            {% endfor %}
            {% for field in fields | filter(attribute="sortable", value="descending_only") %}
            Self::{{field.pascal_case_name}} => descending == true,
            {% endfor %}
            _ => true
        }
    }
}

impl std::str::FromStr for OrderByField {
    type Err = OrderByError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = match s {
            {% for field in fields  %}
            {% if field.sortable != "none" %}
            "{{field.sql_name}}" => OrderByField::{{field.pascal_case_name}},
            {% endif %}
            {% endfor %}
            _ => return Err(OrderByError::InvalidField),
        };

        Ok(value)
    }
}

fn parse_order_by(field: &str) -> Result<(bool, OrderByField), OrderByError> {
    let descending = field.starts_with('-');
    let field = if descending {
        &field[1..]
    } else {
        field
    };

    let value = OrderByField::from_str(field)?;
    if !value.allowed_direction(descending) {
        return Err(OrderByError::InvalidDirection);
    }
    Ok((descending, value))
}

{% set_global has_filterable = false %}

#[derive(Serialize, Debug)]
pub struct ListQueryFilters {
    {%if not pagination.disable %}
    pub page: Option<u32>,
    pub per_page: Option<u32>,
    {% endif %}
    pub order_by: Option<String>,

    {%- for field in fields | filter(attribute="filterable", value="exact") -%}
        {% set_global has_filterable = true %}
    #[serde(default)]
    pub {{field.rust_name}}: Vec<{{field.base_rust_type}}>,
    {%- endfor -%}
    {%- for field in fields | filter(attribute="filterable", value="range") -%}
        {% set_global has_filterable = true %}
    pub {{field.rust_name}}_lte: Option<{{field.base_rust_type}}>,
    pub {{field.rust_name}}_gte: Option<{{field.base_rust_type}}>,
    {%- endfor -%}
}

impl ListQueryFilters {
    fn build_where_clause(&self) -> String {
        {% set start_binding = 3 %}
        {% if not pagination.disable %}
          {% set start_binding = start_binding + 2 %}
        {% endif %}
        let mut bindings = WhereBuilder::new({{ start_binding }});

        {% for field in fields | filter(attribute="filterable", value="exact") %}
            if !self.{{field.rust_name}}.is_empty() {
                bindings.add_vec("{{field.sql_name}}", &self.{{field.rust_name}});
            }
        {% endfor %}
        {% for field in fields | filter(attribute="filterable", value="range") %}
            if self.{{field.rust_name}}_lte.is_some() {
                bindings.add_option("{{field.sql_name}}", &self.{{field.rust_name}}_lte, BindingOperator::Lte);
            }

            if self.{{field.rust_name}}_gte.is_some() {
                bindings.add_option("{{field.sql_name}}", &self.{{field.rust_name}}_gte, BindingOperator::Gte);
            }
        {% endfor %}
        
        bindings.to_string()
    }

    fn bind_to_query(&self, mut query: sqlx::query::Query) -> sqlx::query::Query {
        {% if not pagination.disable %}
            const MAX_PER_PAGE: u32 = {{ pagination.max_per_page }};
            const DEFAULT_PER_PAGE: u32 = {{ pagination.default_per_page }};
            let per_page = self.per_page.unwrap_or(DEFAULT_PER_PAGE).min(MAX_PER_PAGE).max(1);
            let offset = self.page.unwrap_or(0) * per_page;
            query = query.bind(per_page).bind(offset);
        {% endif %}



        {% for field in fields | filter(attribute="filterable", value="exact") %}
            if !self.{{field.rust_name}}.is_empty() {
                query = query.bind(&self.{{field.rust_name}});
            }
        {% endfor %}
        {% for field in fields | filter(attribute="filterable", value="range") %}
            {% set_global has_filterable = true %}
            if self.{{field.rust_name}}_lte.is_some() {
                query = query.bind(&self.{{field.rust_name}}_lte);
            }

            if self.{{field.rust_name}}_gte.is_some() {
                query = query.bind(&self.{{field.rust_name}}_gte);
            }
        {% endfor %}

        query
    }
}

pub async fn list(db: &PgPool, auth: &AuthInfo, filters: &ListQueryFilters) -> Result<Vec<{{ struct_base }}FilteredView>, Report<Error>> {
    let q = include_str!("{{dir}}/list.sql");

    let (descending, order_by_field) = parse_order_by(filters.order_by.as_deref().unwrap_or("{{default_sort_field}}"))?;
    let order_direction = if descending { "DESC" } else { "ASC" };

    let q = q.replace("<order_by>", &format!("{} {}", order_by_field.as_str(), order_direction));
    {% if has_filterable %}
        let q = q.replace("<filters>", &filters.build_where_clause());
    {% endif %}
    let mut query = sqlx::query_as::<_, {{struct_base}}OwnerView>(q.as_str());

    query = query.bind(auth.org_id)
        .bind(&auth.actor_ids);

    query = filters.bind_to_query(query);

    let results = query
        .fetch_all(db)
        .map({{struct_base}}FilteredView::from_item)
        .await
        .change_context(Error::Db)?;

    Ok(results)
}

pub async fn create(db: &PgPool, auth: &AuthInfo, object: &{{struct_base}}CreatePayload) -> Result<{{struct_base}}OwnerView, Error> {
    let id = {{id_type}}::new();
    let result = query_file_as!({{struct_base}}OwnerView, "{{dir}}/insert.sql",
        id.as_uuid(),
        auth.org_id.as_uuid(),
        {% for field in fields | filter(attribute="owner_write", value=true) %}
            &payload.{{field.rust_name}},
        {% endfor %}
        )
        .fetch_one(db)
        .await
        .change_context(Error::Db)?;

    Ok(result)
}

pub async fn update(db: &PgPool, auth: &AuthInfo, id: {{id_type}}, payload: &{{ struct_base }}UpdatePayload) -> Result<(), Error> {
    query_file!("{{dir}}/update.sql",
        id.as_uuid(),
        auth.org_id.as_uuid(),
        {% for field in fields | filter(attribute="owner_write", value=true) %}
            &payload.{{field.rust_name}},
        {% endfor %}
        )
        .execute(db)
        .await
        .change_context(Error::Db)?;
    Ok(())
}

pub async fn delete(db: &PgPool, auth: &AuthInfo, id: {{id_type}}) -> Result<(), Error> {
    query_file!("{{dir}}/delete.sql",
        id.as_uuid(),
        auth.org_id.as_uuid()
        )
        .execute(db)
        .await
        .change_context(Error::Db)?;
    Ok(())
}
