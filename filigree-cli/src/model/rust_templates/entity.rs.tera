#![allow(unused_imports, dead_code)]
use super::{
    {{id_type}}, CREATE_PERMISSION, READ_PERMISSION, WRITE_PERMISSION,
};
use crate::{auth::AuthInfo, error::Error}; 
{%- if id_type != "OrganizationId" %}
use crate::models::organization::OrganizationId;
{% endif -%}
{{rust_imports}}
use filigree::auth::ObjectPermission;
use sea_orm::prelude::*;
use serde::{
    ser::{Serializer, SerializeStruct},
    Serialize, Deserialize
};
use sqlx_transparent_json_decode::sqlx_json_decode;

{% for struct in structs | filter(attribute="is_primary_model", value = true) %}
#[derive(Serialize, Deserialize, Debug, Clone, schemars::JsonSchema, sqlx::FromRow, DeriveEntityModel)]
#[sea_orm(table_name = "{{table}}" {% if schema %}, schema_name = "{{schema}}" {% endif %})]
pub struct {{ struct.rust_name }} {
    {%- if struct.is_primary_model -%}#[sea_orm(primary_key)]{% endif %}
    {{ struct.rust_fields_content }}
}
{% endfor %}

#[derive(Copy, Clone, Debug, sea_orm::EnumIter, sea_orm::DeriveRelation)]
pub enum Relation {
    {% if belongs_to_field -%}
    #[sea_orm(
        belongs_to = "crate::models::{{belongs_to_field.module}}::Entity",
        from = "Column::{{belongs_to_field.camel_case_name}}",
        to = "crate::models::{{belongs_to_field.module}}::Column::Id",
    )]
    {{belongs_to_field.model}},
    {%- endif -%}
    {% for child in children %}
    #[sea_orm(
        {% if child.relationship.many %}has_many{% else %}has_one{% endif %} = "crate::models::{{child.module}}::Entity",
    )]
    {{child.relationship.model}},
    {% endfor %}
}

{% if belongs_to_field %}
impl Related<crate::models::{{belongs_to_field.module}}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{belongs_to_field.model}}.def()
    }
}
{% endif %}

{% for child in children %}
impl Related<crate::models::{{child.module}}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{child.relationship.model}}.def()
    }
}
{% endfor %}

impl sea_orm::ActiveModelBehavior for ActiveModel {}

/// An Entity class that automatically checks for authorization on any query.
pub struct AuthedEntity<'a> {
    auth_info: &'a AuthInfo,
}

impl AuthedEntity {
    pub fn new(auth_info: &AuthInfo) -> Self {
        Self { auth_info }
    }

    pub fn belongs_to<R>(related: R) -> sea_orm::RelationBuilder<Entity, R>
    where
        R: EntityTrait,
    {
        Entity::belongs_to(related)
    }

    pub fn has_one<R>(related: R) -> sea_orm::RelationBuilder<Entity, R>
    where
        R: EntityTrait + Related<Entity>,
    {
        Entity::has_one(related)
    }

    pub fn has_many<R>(related: R) -> sea_orm::RelationBuilder<Entity, R>
    where
        R: EntityTrait + Related<Entity>,
    {
        Entity::has_many(related)
    }

    pub fn find() -> Result<Select<Entity>, Error> {
        self.check_list(Entity::find())
    }

    pub fn find_by_id<T>(values: T) -> Select<Entity>
    where
        T: Into<<Entity::PrimaryKey as PrimaryKeyTrait>::ValueType>,
    {
        self.check_get(Entity::find_by_id(values))
    }

    pub fn insert<A>(model: A) -> sea_orm::Insert<A>
    where
        A: ActiveModelTrait<Entity = Entity>,
    {
        self.check_insert(Entity::insert(model))
    }

    pub fn insert_many<A, I>(models: I) -> sea_orm::Insert<A>
    where
        A: ActiveModelTrait<Entity = Entity>,
        I: IntoIterator<Item = A>,
    {
        self.check_insert(Entity::insert_many(models))
    }

    pub fn update<A>(model: A) -> sea_orm::UpdateOne<A>
    where
        A: ActiveModelTrait<Entity = Entity>,
    {
        self.check_update_one(Entity::update(model))
    }

    pub fn update_many() -> sea_orm::UpdateMany<Entity> {
        self.check_update_many(Entity::update_many())
    }

    pub fn delete<A>(model: A) -> sea_orm::DeleteOne<A>
    where
        A: ActiveModelTrait<Entity = Entity>,
    {
        self.check_delete_one(Entity::delete(model))
    }

    pub fn delete_many() -> sea_orm::DeleteMany<Entity> {
        self.check_delete_many(Entity::delete_many())
    }

    pub fn delete_by_id<T>(values: T) -> sea_orm::DeleteMany<Entity>
    where
        T: Into<<Entity::PrimaryKey as PrimaryKeyTrait>::ValueType>,
    {
        self.check_delete_many(Entity::delete_by_id(values))
    }

    /// Add a clause that filters a list-style query
    pub fn check_list(&self, select: Select<Entity>) -> Result<Select<Entity>, Error> {
        if self.auth_info.has_permission(READ_PERMISSION) {
            Ok(select.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(READ_PERMISSION))
        }
    }

    pub fn check_get(&self, select: Select<Entity>) -> Result<Select<Entity>, Error> {
        if self.auth_info.has_permission(READ_PERMISSION) {
            Ok(select.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(READ_PERMISSION))
        }
    }

    pub fn check_update_one(&self, update: UpdateOne<Entity>) -> Result<UpdateOne<Entity>, Error> {
        if self.auth_info.has_permission(WRITE_PERMISSION) {
            Ok(update.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(WRITE_PERMISSION))
        }
    }

    pub fn check_update_many(
        &self,
        update: UpdateMany<Entity>,
    ) -> Result<UpdateMany<Entity>, Error> {
        if self.auth_info.has_permission(WRITE_PERMISSION) {
            Ok(update.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(WRITE_PERMISSION))
        }
    }

    pub fn check_insert(&self, insert: Insert<Entity>) -> Result<Insert<Entity>, Error> {
        if self.auth_info.has_permission(CREATE_PERMISSION) {
            Ok(insert)
        } else {
            Err(crate::Error::MissingPermission(CREATE_PERMISSION))
        }
    }

    pub fn check_delete_one(&self, del: DeleteOne<Entity>) -> Result<DeleteOne<Entity>, Error> {
        if self.auth_info.has_permission(CREATE_PERMISSION) {
            Ok(del.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(CREATE_PERMISSION))
        }
    }

    pub fn check_delete_many(&self, del: DeleteMany<Entity>) -> Result<DeleteMany<Entity>, Error> {
        if self.auth_info.has_permission(CREATE_PERMISSION) {
            Ok(del.filter(Column::OrganizationId.eq(self.auth_info.organization_id.as_ref())))
        } else {
            Err(crate::Error::MissingPermission(CREATE_PERMISSION))
        }
    }
}

