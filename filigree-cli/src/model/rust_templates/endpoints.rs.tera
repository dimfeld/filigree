use axum::{Json, extract::{State, Path, Query}, http::StatusCode, routing};
use filigree::sql::QueryBindings;

use crate::auth::AuthInfo;

use super::queries;

async fn get(
    State(state): State<AppState>,
    AuthInfo(auth): AuthInfo,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    let object = queries::get(&state.db, &auth, id).await?;

    {% if user_view_struct != owner_view_struct %}
    let object = if auth.permissions.contains({{owner_permission}}) {
        {{struct_base}}FilteredView::Owner(result)
    } else {
        {{struct_base}}FilteredView::User(result.into())
    };
    {% endif %}

    Ok(Json(object))
}

async fn list(
    State(state): State<AppState>,
    AuthInfo(auth): AuthInfo,
    Query(qs): Query<ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {
    let results = queries::list(&state.db, &auth, &qs).await?;

    {# In most cases, the user view is the same as the owner view #}
    {% if user_view_struct != owner_view_struct %}
        // If it is not an owner, switch to the user view
        let results = results.into_iter()
            .map(|result| {
                if auth.permissions.contains({{owner_permission}}) {
                    {{struct_base}}FilteredView::Owner(result)
                } else {
                    {{struct_base}}FilteredView::User(result.into())
                }
            })
            .collect::<Vec<_>>();
    {% endif %}

    Ok(Json(results))
}

async fn create(
    State(state): State<AppState>,
    AuthInfo(auth): AuthInfo,
    Json(payload): Json<{{ struct_base }}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    let result = queries::create(&state.db, &auth, &payload).await?;

    Ok((StatusCode::CREATED, Json(result)));
}

async fn update(
    State(state): State<AppState>,
    AuthInfo(auth): AuthInfo,
    Json(payload): Json<{{ struct_base }}UpdatePayload>,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    queries::update(&state.db, &auth, id, &payload).await?;
    Ok(StatusCode::OK);
}

async fn delete(
    State(state): State<AppState>,
    AuthInfo(auth): AuthInfo,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    queries::delete(&state.db, &auth, id).await?;

    Ok(StatusCode::OK);
}

pub fn create_routes() -> axum::Router<AppState> {
    axum::Router::new()
        {% if endpoints.list %}.route("/{{ url_path }}", routing::get(list)){% endif %}
        {% if endpoints.get %}.route("/{{ url_path }}/:id", routing::get(get)){% endif %}
        {% if endpoints.create %}.route("/{{ url_path }}", routing::post(create)){% endif %}
        {% if endpoints.update %}.route("/{{ url_path }}/:id", routing::put(update)){% endif %}
        {% if endpoints.delete %}.route("/{{ url_path }}/:id", routing::delete(delete)){% endif %}
}

