{% if has_any_endpoints or custom_endpoints | length -%}
#![allow(unused_imports, unused_variables, dead_code)]
use std::{borrow::Cow, str::FromStr};

use axum::{extract::{State, Path}, http::StatusCode, response::IntoResponse, routing};
use axum_jsonschema::Json;
use axum_extra::extract::Query;
use error_stack::ResultExt;
use filigree::{auth::{AuthError, ObjectPermission}, extract::FormOrJson};
use tracing::{event, Level};

use crate::{Error, auth::{Authed, has_any_permission}, server::ServerState};
{{rust_imports}}

use super::{queries, types::*, {{id_type}}, CREATE_PERMISSION, OWNER_PERMISSION, READ_PERMISSION, WRITE_PERMISSION };


async fn get(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_get %}
    let object = {{struct_base}}::get_populated(&state.db, &auth, &id).await?;
    {% else %}
    let object = {{struct_base}}::get(&state.db, &auth, &id).await?;
    {% endif %}
    Ok(Json(object))
}

async fn list(
    State(state): State<ServerState>,
    auth: Authed,
    Query(qs): Query<queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_list %}
    let results = {{struct_base}}::list_populated(&state.db, &auth, &qs).await?;
    {% else %}
    let results = {{struct_base}}::list(&state.db, &auth, &qs).await?;
    {% endif %}
    Ok(Json(results))
}

async fn create(
    State(state): State<ServerState>,
    auth: Authed,
    FormOrJson(payload): FormOrJson<{{ struct_base }}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    let mut tx = state.db.begin().await.change_context(Error::Db)?;
    let result = {{struct_base}}::create(&mut *tx, &auth, payload).await?;
    tx.commit().await.change_context(Error::Db)?;

    Ok((StatusCode::CREATED, Json(result)))
}

async fn update(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    FormOrJson(payload): FormOrJson<{{ struct_base }}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    let result = {{struct_base}}::update(&mut *tx, &auth, &id, payload).await?;

    tx.commit().await.change_context(Error::Db)?;

    if result {
        Ok(StatusCode::OK)
    } else {
        Ok(StatusCode::NOT_FOUND)
    }
}

async fn delete(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    {% for c in children
        | filter(attribute="file_upload")
        | filter(attribute="file_upload.retain_file_on_delete", value=false) -%}
    let {{ c.module }}_files = crate::models::{{c.module}}::storage::get_storage_keys_by_parent_id(
        &state, &auth, &mut *tx, id
    ).await?;
    {%- endfor %}

    let deleted = {{struct_base}}::delete(&mut *tx, &auth, &id).await?;

    if !deleted {
        return Ok(StatusCode::NOT_FOUND);
    }

    tx.commit().await.change_context(Error::Db)?;

    {% for c in children
        | filter(attribute="file_upload")
        | filter(attribute="file_upload.retain_file_on_delete", value=false) -%}
    for file in {{ c.module }}_files {
        crate::models::{{c.module}}::storage::delete_by_key(&state, &file).await?;
    }
    {%- endfor %}

    Ok(StatusCode::OK)
}

{% for c in children %}

async fn list_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    Query(mut qs): Query<crate::models::{{c.module}}::queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {

    qs.{{c.parent_field}} = vec![parent_id];

    let object = crate::models::{{c.module}}::{{c.model}}::list(
        &state.db,
        &auth,
        &qs
        ).await?;

    {% if not c.relationship.many %}
    let object = object
        .into_iter()
        .next()
        .ok_or(Error::NotFound("{{c.relationship.model}}"))?;
    {% endif %}

    Ok(Json(object))
}


{% if c.relationship.many %}
async fn get_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
) -> Result<impl IntoResponse, Error> {
    let object = crate::models::{{c.module}}::{{c.model}}::get(&state.db, &auth, &child_id).await?;
    if object.{{c.parent_field}} != parent_id {
        return Err(Error::NotFound("Parent {{name}}"));
    }

    Ok(Json(object))
}

async fn create_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    {% if c.file_upload -%}
    Query(qs): Query<filigree::storage::QueryFilename>,
    body: axum::body::Body,
    {%- else -%}
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}CreatePayload>,
    {%- endif %}
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    {% if c.file_upload %}
    let result = crate::models::{{c.module}}::storage::upload_stream(
        &state,
        &auth,
        &mut *tx,
        parent_id,
        None,
        qs.filename.clone(),
        None,
        {% if c.file_upload.upload_size_limit %}Some({{c.file_upload.upload_size_limit}}){% else %}None{% endif %},
        body.into_data_stream()
    ).await?;
    {% else %}
    payload.{{c.parent_field}} = parent_id;

    let result = crate::models::{{c.module}}::{{c.model}}::create(
        &mut *tx,
        &auth,
        payload
    ).await?;
    {% endif %}

    tx.commit().await.change_context(Error::Db)?;

    Ok(Json(result))
}

{% if not c.file_upload %}
async fn update_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    payload.id = Some(child_id);
    payload.{{c.parent_field}} = parent_id;

    let object_perm = {{struct_base}}::lookup_object_permissions(
        &state.db,
        &auth,
        &parent_id,
    ).await?
    .unwrap_or(ObjectPermission::Read);

    object_perm.must_be_writable(WRITE_PERMISSION)?;

    let result = crate::models::{{c.module}}::{{c.model}}::update_one_with_parent(
        &state.db,
        &auth,
        &parent_id,
        &child_id,
        payload).await?;

    Ok(Json(result))
}
{% endif %}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    ) -> Result<impl IntoResponse, Error> {

    {% if c.file_upload and not c.file_upload.retain_file_on_delete %}
    let mut tx = state.db.begin()
        .await
        .change_context(Error::Db)?;
    let deleted = crate::models::{{c.module}}::storage::delete_by_id(
        &state,
        &auth,
        &mut *tx,
        parent_id,
        child_id,
    ).await?;
    tx.commit()
        .await
        .change_context(Error::Db)?;
    {% else %}
    let deleted = crate::models::{{c.module}}::{{c.model}}::delete_with_parent(
        &state.db,
        &auth,
        &parent_id,
        &child_id,
    ).await?;
    {% endif %}

    if deleted {
        Ok(StatusCode::OK)
    } else {
        Ok(StatusCode::NOT_FOUND)
    }
}

{% else %}
async fn upsert_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    {% if c.file_upload -%}
    Query(qs): Query<filigree::storage::QueryFilename>,
    body: axum::body::Body,
    {%- else -%}
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    {%- endif %}
    ) -> Result<impl IntoResponse, Error> {
    payload.{{c.parent_field}} = parent_id;

    let object_perm = {{struct_base}}::lookup_object_permissions(
        &state.db,
        &auth,
        &parent_id,
    ).await?
    .unwrap_or(ObjectPermission::Read);

    object_perm.must_be_writable(WRITE_PERMISSION)?;

    {% if c.file_upload %}
    let mut tx = state.db.begin().await?;
    {% if not c.file_upload.retain_file_on_update %}
    let old_storage_key = sqlx::query_scalar!(
        "SELECT file_storage_key FROM {{c.table}} WHERE {{c.parent_field}} = $1",
        parent_id
    )
        .fetch_optional(&mut *tx)
        .await?;
    {% endif %}

    crate::models::{{c.module}}::storage::upload_stream(
        &state,
        &auth,
        &mut state.db,
        parent_id,
        None,
        qs.filename.clone(),
        None,
        {% if c.file_upload.upload_size_limit %}Some({{c.file_upload.upload_size_limit}}){% else %}None{% endif %},
        body.into_data_stream()
    ).await?;

    tx.commit()
        .await
        .change_context(Error::Db)?;

    {% if not c.file_upload.retain_file_on_update %}
    if let Some(old_storage_key) = old_storage_key {
        crate::models::{{c.module}}::storage::delete_by_key(
            &state,
            &old_storage_key
        )
            .await?;
    }
    {% endif %}


    {% else %}
    let result = crate::models::{{c.module}}::{{c.model}}::upsert_with_parent(
        &state.db,
        &auth.organization_id,
        &parent_id,
        &payload).await?;
    {% endif %}
    Ok(Json(result))
}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    ) -> Result<impl IntoResponse, Error> {
    let object_perm = {{struct_base}}::lookup_object_permissions(
        &state.db,
        &auth,
        &parent_id,
    ).await?
    .unwrap_or(ObjectPermission::Read);

    object_perm.must_be_writable(WRITE_PERMISSION)?;

    {% if c.file_upload and not c.file_upload.retain_file_on_delete %}
    let mut tx = state.db.begin()
        .await
        .change_context(Error::Db)?;

    let deleted = crate::models::{{c.module}}::storage::delete_by_parent_id(
        &state,
        &auth,
        &mut *tx,
        parent_id,
        child_id,
    ).await?;

    tx.commit()
        .await
        .change_context(Error::Db)?;
    {% else %}
    let deleted = crate::models::{{c.module}}::{{c.model}}::delete_all_children_of_parent(
        &state.db,
        &auth.organization_id,
        &parent_id).await?;
    {% endif %}

    if deleted {
        Ok(StatusCode::OK)
    } else {
        Ok(StatusCode::NOT_FOUND)
    }
}
{% endif %}

{% endfor %}

{% for e in custom_endpoints %}

{{e.rust.input_type_def}}

{{e.rust.output_type_def}}

{{e.rust.query_type_def}}

async fn {{ e.snake_name }}(
    {{e.rust.args}}
) -> Result<impl IntoResponse, Error> {
    // Add your code here

    let output = {{e.output_type}} {
        // add data here
    };

    Ok(Json(output))
}
{% endfor %}

pub fn create_routes() -> axum::Router<ServerState> {
    axum::Router::new()
        {% if endpoints.list %}.route("/{{ url_path }}",
            routing::get(list)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.get %}.route("/{{ url_path }}/:id",
            routing::get(get)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.create %}.route("/{{ url_path }}",
            routing::post(create)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.update %}.route("/{{ url_path }}/:id",
            routing::put(update)
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.delete %}.route("/{{ url_path }}/:id",
            routing::delete(delete)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}

    {% for c in children %}
    {% if endpoints.list %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::get(list_child_{{c.module}})
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
    {% endif %}

    {% if endpoints.create %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            {% if c.relationship.many %}
            routing::post(create_child_{{c.module}})
            {% else %}
            routing::post(upsert_child_{{c.module}})
            {% endif %}
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
            )
    {% endif %}

    {% if endpoints.get and c.relationship.many %}
        .route(
            "/{{url_path}}/:id/{{c.url_path}}/:child_id",
            routing::get(get_child_{{c.module}})
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])),
        )
    {% endif %}

    {% if endpoints.update %}
        {% if c.relationship.many %}
            {% if not c.file_upload %}
                .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
                        routing::put(update_child_{{c.module}})
                    .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"]))
                )
            {% endif %}
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::put(upsert_child_{{c.module}})
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"]))
            )
        {% endif %}
    {% endif %}

    {% if endpoints.delete %}
        {% if c.relationship.many %}
        .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
        {% endif %}
        routing::delete(delete_child_{{c.module}})
            .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
        )

    {% endif %}
    {% endfor %}

    {% for e in custom_endpoints %}
        .route("{{e.rust.path}}",
            routing::{{e.rust.method}}({{e.snake_name}})
                .route_layer(has_any_permission(vec![{{e.rust.permission}}, "org_admin"]))
            )
    {% endfor %}
}

#[cfg(test)]
mod test {
    use filigree::testing::ResponseExt;
    use futures::{StreamExt, TryStreamExt};
    use tracing::{event, Level};

    use super::*;
    use super::super::testing::{make_create_payload, make_update_payload};
    use crate::{
        {% if model_name != "Organization" %}
        models::organization::OrganizationId,
        {% endif %}
        tests::{start_app, BootstrappedData},
    };

    async fn setup_test_objects(
        db: &sqlx::PgPool,
        organization_id: OrganizationId,
        count: usize,
    ) -> Vec<({{struct_base}}CreatePayload, {{struct_base}}CreateResult)> {
        let mut tx = db.begin().await.unwrap();
        let mut objects = Vec::with_capacity(count);
        for i in 0..count {
            let id = {{new_object_id}};
            event!(Level::INFO, %id, "Creating test object {}", i);
            let payload = make_create_payload(i);
            let result = {{struct_base}}::create_raw(
                &mut *tx,
                &id,
                &organization_id,
                payload.clone(),
            )
            .await
            .expect("Creating test object failed");

            objects.push((payload, result));
        }

        tx.commit().await.unwrap();
        objects
    }

    {% if endpoints.list %}
    #[sqlx::test]
    async fn list_objects(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                user,
                {% if model_name == "Role" %}
                admin_role,
                user_role,
                {% endif %}
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = admin_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {# Filter out fixed objects that were created in the bootstrapping process, since it makes testing
        easier. #}
        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        assert_eq!(results.len(), added_objects.len());

        for result in results {
            let (payload, added) = added_objects.iter().find(|i| i.1.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="owner_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "field {{field.rust_name}}"
            );
            {% if field.writable %}
            assert_eq!(
                payload.{{field.rust_name}},
                added.{{field.rust_name}},
                "create result field {{field.rust_name}}"
            );
            {% endif %}
            {%- endfor %}

            {% for field in fields | filter (attribute="owner_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }

        let results = user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        for result in results {
            let (payload, added) = added_objects.iter().find(|i| i.1.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="user_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "list result field {{field.rust_name}}"
            );
            {%- endfor %}

            {% for child in children %}
            {% if child.relationship.populate_on_list == "id" %}
                {% if child.write_payload_field_name %}
                    {% if child.relationship.many %}
                    let ids = added.{{child.write_payload_field_name}}
                        .iter()
                        .map(|o| o.id).collect::<Vec<_>>();
                    {% else %}
                    let ids = added.{{child.write_payload_field_name}};
                    {% endif %}
                    let ids = serde_json::to_value(&ids).unwrap();
                {%- elif child.relationship.many %}
                let ids = serde_json::json!([]);
                {% else %}
                let ids = serde_json::json!(null);
                {% endif %}
                assert_eq!(
                    result["{{child.list_sql_field_name}}"],
                    ids,
                    "field {{child.list_sql_field_name}}"
                );
            {% elif child.relationship.populate_on_list == "data" %}
                assert_eq!(
                    result["{{child.list_sql_field_name}}"],
                    {% if child.write_payload_field_name %}
                    serde_json::to_value(&payload.{{child.write_payload_field_name}}).unwrap(),
                    {% else %}
                    serde_json::json!([]),
                    {% endif %}
                    "field {{child.list_sql_field_name}}"
                );
            {% elif chil %}
                // Check all the possibilities for a child field being populated
                {% for f in child.possible_child_field_names -%}
                assert!(result.get("{{f}}").is_none());
                {%- endfor %}
            {% endif %}
            {% endfor %}

            {% for field in fields | filter (attribute="user_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }


        let response = no_roles_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);

    }

    #[sqlx::test]
    async fn list_fetch_specific_ids(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = user
            .client
            .get("{{url_path}}")
            .query(&[
                ("id", added_objects[0].1.id),
                ("id", added_objects[2].1.id),
            ])
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        assert_eq!(results.len(), 2);
        assert!(results.iter().any(|o| o["id"] == added_objects[0].1.id.to_string()));
        assert!(results.iter().any(|o| o["id"] == added_objects[2].1.id.to_string()));
    }

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_order_by(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_paginated(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_filters(_pool: sqlx::PgPool) {}
    {% endif %}

    {% if endpoints.get %}
    #[sqlx::test]
    async fn get_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let (payload, added) = &added_objects[1];
        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "get result field {{field.rust_name}}"
        );
        {% if field.writable %}
        assert_eq!(
            added.{{field.rust_name}},
            payload.{{field.rust_name}},
            "create result field {{field.rust_name}}"
        );
        {% endif %}
        {%- endfor %}

        {% for child in children %}
        {% if child.relationship.populate_on_get == "id" %}
            {% if child.write_payload_field_name %}
                {% if child.relationship.many %}
                let ids = added.{{child.write_payload_field_name}}
                    .iter()
                    .map(|o| o.id)
                    .collect::<Vec<_>>();
                {% else %}
                let ids = added.{{child.write_payload_field_name}};
                {% endif %}
                let ids = serde_json::to_value(&ids).unwrap();
            {%- elif child.relationship.many %}
            let ids = serde_json::json!([]);
            {% else %}
            let ids = serde_json::json!(null);
            {% endif %}
            assert_eq!(
                result["{{child.get_sql_field_name}}"],
                ids,
                "field {{child.get_sql_field_name}}"
            );
        {% elif child.relationship.populate_on_get == "data" %}
            assert_eq!(
                result["{{child.get_sql_field_name}}"],
                {% if child.write_payload_field_name %}
                serde_json::to_value(&added.{{child.write_payload_field_name}}).unwrap(),
                {% elif child.relationship.many %}
                serde_json::json!([]),
                {% else %}
                serde_json::json!(null),
                {% endif %}
                "field {{child.get_sql_field_name}}"
            );
        {% else %}
            // Check all the possibilities for a child field being populated
            {% for f in child.possible_child_field_names -%}
            assert!(result.get("{{f}}").is_none());
            {%- endfor %}
        {% endif %}
        {% endfor %}

        {% for field in fields | filter (attribute="owner_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let result = user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let (payload, added) = &added_objects[1];
        {% for field in fields | filter (attribute="user_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "get result field {{field.rust_name}}"
        );
        {%- endfor %}

        {% for field in fields | filter (attribute="user_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let response = no_roles_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}


    {% if endpoints.update %}
    #[sqlx::test]
    async fn update_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let update_payload = make_update_payload(20);
        admin_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .json(&update_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let updated: serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="writable", value=true) -%}
        assert_eq!(
            updated["{{field.rust_name}}"],
            serde_json::to_value(&update_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}

        // TODO Test that owner can not write fields which are not writable by anyone.
        // TODO Test that user can not update fields which are writable by owner but not user

        // Make sure that no other objects were updated
        let non_updated : serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            non_updated["{{field.rust_name}}"],
            serde_json::to_value(&added_objects[0].1.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}

        let response = no_roles_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .json(&update_payload)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.create %}
    #[sqlx::test]
    async fn create_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let create_payload = make_create_payload(10);
        let created_result : serde_json::Value = admin_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();


        {% for field in fields | filter (attribute="writable", value=true) -%}
        assert_eq!(
            created_result["{{field.rust_name}}"],
            serde_json::to_value(&create_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}} from create response"
        );
        {%- endfor %}

        let created_id = created_result["id"].as_str().unwrap();
        let get_result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", created_id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            get_result["{{field.rust_name}}"],
            created_result["{{field.rust_name}}"],
            "field {{field.rust_name}} from get response"
        );
        {%- endfor %}

        let response = no_roles_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }

    {% endif %}

    {% if endpoints.delete %}
    #[sqlx::test]
    async fn delete_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        admin_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::NOT_FOUND);

        // Delete should not happen without permissions
        let response = no_roles_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);

        // Make sure other objects still exist
        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::OK);
    }
    {% endif %}

    {% for c in children %}
    {% if c.file_upload %}
    // TODO file upload test for {{c.module}}
    {% else %}
    #[sqlx::test]
    async fn child_{{c.module}}(pool: sqlx::PgPool) {
        // Create a test object
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let (parent_payload, parent_result) = setup_test_objects(&pool, organization.id, 2)
            .await
            .into_iter()
            .next()
            .unwrap();

        // Create a test object
        let payload_one = crate::models::{{c.module}}::testing::make_create_payload(1);
        let create_result_one = admin_user
            .client
            .post(&format!("{{url_path}}/{}/{{c.url_path}}", parent_result.id))
            .json(&payload_one)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();
        let id_one = {{c.object_id}}::from_str(create_result_one["id"].as_str().unwrap()).unwrap();

        // Try to create a test object with a bad parent id
        let bad_parent_id = {{new_object_id}};
        let payload_two = crate::models::{{c.module}}::testing::make_create_payload(1);
        let response = admin_user
            .client
            .post(&format!("{{url_path}}/{}/{{c.url_path}}", bad_parent_id))
            .json(&payload_two)
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::NOT_FOUND);

        {% if c.relationship.many %}
        // Create another test object
        let payload_two = crate::models::{{c.module}}::testing::make_create_payload(2);
        let create_result_two = admin_user
            .client
            .post(&format!("{{url_path}}/{}/{{c.url_path}}", parent_result.id))
            .json(&payload_two)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();
        let id_two = {{c.object_id}}::from_str(create_result_two["id"].as_str().unwrap()).unwrap();
        {% endif %}

        // Check create without permissions
        let bad_create_payload = crate::models::{{c.module}}::testing::make_create_payload(9);
        let res = no_roles_user
            .client
            .post(&format!("{{url_path}}/{}/{{c.url_path}}", parent_result.id))
            .json(&bad_create_payload)
            .send()
            .await
            .unwrap();
        assert_eq!(res.status(), reqwest::StatusCode::FORBIDDEN);

        // Check get without permissions
        let res = no_roles_user
            .client
            .get(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id, id_one
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap();
        assert_eq!(res.status(), reqwest::StatusCode::FORBIDDEN);

        // Check update without permissions
        let bad_update_payload = crate::models::{{c.module}}::testing::make_update_payload(8);
        let res = no_roles_user
            .client
            .put(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id, id_one
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .json(&bad_update_payload)
            .send()
            .await
            .unwrap();
        assert_eq!(res.status(), reqwest::StatusCode::FORBIDDEN);

        // Check delete without permissions
        let res = no_roles_user
            .client
            .delete(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id, id_one
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap();
        assert_eq!(res.status(), reqwest::StatusCode::FORBIDDEN);

        // Check get of test object
        let get_result_one = admin_user
            .client
            .get(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();
        assert_eq!(create_result_one, get_result_one);

        // Check get of test object with a different parent ID
        let get_result_bad_parent = admin_user
            .client
            .get(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                bad_parent_id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                bad_parent_id
            {% endif %}
            ))
            .send()
            .await
            .unwrap();
        assert_eq!(get_result_bad_parent.status(), reqwest::StatusCode::NOT_FOUND);

        // Check update of test object
        let update_payload_one = crate::models::{{c.module}}::testing::make_update_payload(5);
        let update_result_one = admin_user
            .client
            .put(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .json(&update_payload_one)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        // Check update of test object with a different parent ID
        let bad_update_payload = crate::models::{{c.module}}::testing::make_update_payload(5);
        let bad_update_response = admin_user
            .client
            .put(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .json(&bad_update_payload)
            .send()
            .await
            .unwrap();
        // TODO this is broken right now
        // assert_eq!(bad_update_response.status(), reqwest::StatusCode::NOT_FOUND);

        // Check that the data reflects the first update
        let updated_get_result_one = admin_user
            .client
            .get(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();
        // TODO generate comparison for updated_get_result_one and update_payload_one

        // Check delete of test object with a different parent ID
        let delete_result = admin_user
            .client
            .delete(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                bad_parent_id,
                create_result_one["id"].as_str().unwrap()
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                bad_parent_id
            {% endif %}
            ))
            .send()
            .await
            .unwrap();
        assert_eq!(delete_result.status(), reqwest::StatusCode::NOT_FOUND);

        // Check list of test object
        let list_result = admin_user
            .client
            .get(&format!("{{url_path}}/{}/{{c.url_path}}", parent_result.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            {% if c.relationship.many %}
            .json::<Vec<{{c.struct_base}}>>()
            {% else %}
            .json::<{{c.struct_base}}>()
            {% endif %}
            .await
            .unwrap();
        {% if c.relationship.many %}
        assert!(list_result[0].id == id_one || list_result[0].id == id_two);
        assert!(list_result[1].id == id_one || list_result[1].id == id_two);
        // Just make sure that we didn't get the same object twice
        assert_ne!(list_result[0].id, list_result[1].id);
        assert_eq!(list_result.len(), 2);
        {% else %}
        assert!(list_result.id == id_one);
        {% endif %}

        // Check delete of test object
        admin_user
            .client
            .delete(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id, id_one
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let res = admin_user
            .client
            .get(&format!(
            {% if c.relationship.many %}
                "{{url_path}}/{}/{{c.url_path}}/{}",
                parent_result.id, id_one
            {% else %}
                "{{url_path}}/{}/{{c.url_path}}",
                parent_result.id
            {% endif %}
            ))
            .send()
            .await
            .unwrap();
        assert_eq!(res.status(), reqwest::StatusCode::NOT_FOUND);

    }
    {% endif %}
    {% endfor %}

}
{% endif %}{# if has_any_endpoints #}
