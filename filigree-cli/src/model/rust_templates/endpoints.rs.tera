{% if has_any_endpoints -%}
#![allow(unused_imports, dead_code)]
use axum::{extract::{State, Path}, http::StatusCode, response::IntoResponse, routing};
use axum_jsonschema::Json;
use axum_extra::extract::Query;
use error_stack::ResultExt;
use filigree::{auth::ObjectPermission, extract::FormOrJson};
use tracing::{event, Level};

use crate::{Error, auth::{Authed, has_any_permission}, server::ServerState};
{{imports}}

use super::{queries, types::*, {{id_type}}, CREATE_PERMISSION, OWNER_PERMISSION, READ_PERMISSION, WRITE_PERMISSION };

async fn get(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_get %}
    let object = queries::get_populated(&state.db, &auth, id).await?;
    {% else %}
    let object = queries::get(&state.db, &auth, id).await?;
    {% endif %}
    Ok(Json(object))
}

async fn list(
    State(state): State<ServerState>,
    auth: Authed,
    Query(qs): Query<queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_list %}
    let results = queries::list_populated(&state.db, &auth, &qs).await?;
    {% else %}
    let results = queries::list(&state.db, &auth, &qs).await?;
    {% endif %}
    Ok(Json(results))
}

async fn create(
    State(state): State<ServerState>,
    auth: Authed,
    FormOrJson(payload): FormOrJson<{{ struct_base }}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    let mut tx = state.db.begin().await.change_context(Error::Db)?;
    let result = queries::create(&mut *tx, &auth, payload).await?;
    tx.commit().await.change_context(Error::Db)?;

    Ok((StatusCode::CREATED, Json(result)))
}

async fn update(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    FormOrJson(payload): FormOrJson<{{ struct_base }}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    let result = queries::update(&mut *tx, &auth, id, payload).await?;

    tx.commit().await.change_context(Error::Db)?;

    if result {
        Ok(StatusCode::OK)
    } else {
        Ok(StatusCode::NOT_FOUND)
    }
}

async fn delete(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    let deleted = queries::delete(&mut *tx, &auth, id).await?;

    if !deleted {
        return Ok(StatusCode::NOT_FOUND);
    }

    tx.commit().await.change_context(Error::Db)?;
    Ok(StatusCode::OK)
}

{% for c in children %}

async fn list_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    Query(mut qs): Query<crate::models::{{c.module}}::queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {

    qs.{{c.parent_field}} = vec![parent_id];

    let object = crate::models::{{c.module}}::queries::list(
        &state.db,
        &auth,
        &qs
        ).await?;

    {% if not c.relationship.many %}
    let object = object
        .into_iter()
        .next()
        .ok_or(Error::NotFound("{{c.relationship.model}}"))?;
    {% endif %}

    Ok(Json(object))
}


{% if c.relationship.many %}
async fn create_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    payload.{{c.parent_field}} = parent_id;

    let mut tx = state.db.begin().await.change_context(Error::Db)?;
    let result = crate::models::{{c.module}}::queries::create(
        &mut *tx,
        &auth,
        payload
    ).await?;
    tx.commit().await.change_context(Error::Db)?;


    Ok(Json(result))
}

async fn update_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    payload.id = Some(child_id);
    payload.{{c.parent_field}} = parent_id;

    let result = crate::models::{{c.module}}::queries::update_one_with_parent(
        &state.db,
        &auth,
        true, // TODO get the right value here
        parent_id,
        child_id,
        payload).await?;

    Ok(Json(result))
}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    ) -> Result<impl IntoResponse, Error> {

    crate::models::{{c.module}}::queries::delete_with_parent(
        &state.db,
        &auth,
        parent_id,
        child_id,
    ).await?;

    Ok(StatusCode::OK)
}

{% else %}

async fn upsert_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    FormOrJson(mut payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    payload.{{c.parent_field}} = parent_id;

    let object_perm = queries::lookup_object_permissions(
        &state.db,
        &auth,
        parent_id,
    ).await?
    .unwrap_or(ObjectPermission::Read);

    object_perm.must_be_writable(WRITE_PERMISSION)?;

    let result = crate::models::{{c.module}}::queries::update_with_parent(
        &state.db,
        auth.organization_id,
        object_perm == ObjectPermission::Owner,
        parent_id,
        &Some(payload)).await?;
    Ok(Json(result))
}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    ) -> Result<impl IntoResponse, Error> {
    let object_perm = queries::lookup_object_permissions(
        &state.db,
        &auth,
        parent_id,
    ).await?
    .unwrap_or(ObjectPermission::Read);

    object_perm.must_be_writable(WRITE_PERMISSION)?;

    crate::models::{{c.module}}::queries::delete_all_children_of_parent(
        &state.db,
        auth.organization_id,
        parent_id).await?;

    Ok(StatusCode::OK)
}
{% endif %}

{% endfor %}


pub fn create_routes() -> axum::Router<ServerState> {
    axum::Router::new()
        {% if endpoints.list %}.route("/{{ url_path }}",
            routing::get(list)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.get %}.route("/{{ url_path }}/:id",
            routing::get(get)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.create %}.route("/{{ url_path }}",
            routing::post(create)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.update %}.route("/{{ url_path }}/:id",
            routing::put(update)
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.delete %}.route("/{{ url_path }}/:id",
            routing::delete(delete)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}

    {% for c in children %}
    {% if endpoints.list %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::get(list_child_{{c.module}})
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
    {% endif %}

    {% if endpoints.create %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            {% if c.relationship.many %}
            routing::post(create_child_{{c.module}})
            {% else %}
            routing::post(upsert_child_{{c.module}})
            {% endif %}
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
            )
    {% endif %}

    {% if endpoints.update %}
        {% if c.relationship.many %}
        .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
            routing::put(update_child_{{c.module}})
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::put(upsert_child_{{c.module}})
        {% endif %}
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"]))
            )
    {% endif %}

    {% if endpoints.delete %}
        {% if c.relationship.many %}
        .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
        {% endif %}
        routing::delete(delete_child_{{c.module}})
            .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
        )

    {% endif %}
    {% endfor %}
}

#[cfg(test)]
mod test {
    use filigree::testing::ResponseExt;
    use futures::{StreamExt, TryStreamExt};
    use tracing::{event, Level};

    use super::*;
    use super::super::testing::{make_create_payload, make_update_payload};
    use crate::{
        {% if model_name != "Organization" %}
        models::organization::OrganizationId,
        {% endif %}
        tests::{start_app, BootstrappedData},
    };

    async fn setup_test_objects(
        db: &sqlx::PgPool,
        organization_id: OrganizationId,
        count: usize,
    ) -> Vec<({{struct_base}}CreatePayload, {{struct_base}})> {
        // TODO if this model belongs_to another, then create the parent object for it

        let mut tx = db.begin().await.unwrap();
        let mut objects = Vec::with_capacity(count);
        for i in 1..=count {
            let id = {{id_type}}::new();
            event!(Level::INFO, %id, "Creating test object {}", i);
            let payload = make_create_payload(i);
            let result = super::queries::create_raw(
                &mut *tx,
                id,
                organization_id,
                payload.clone(),
            )
            .await
            .expect("Creating test object failed");

            objects.push((payload, result));
        }

        tx.commit().await.unwrap();
        objects
    }

    {% if endpoints.list %}
    #[sqlx::test]
    async fn list_objects(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                user,
                {% if model_name == "Role" %}
                admin_role,
                user_role,
                {% endif %}
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = admin_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {# Filter out fixed objects that were created in the bootstrapping process, since it makes testing
        easier. #}
        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        assert_eq!(results.len(), added_objects.len());

        for result in results {
            let (payload, added) = added_objects.iter().find(|i| i.1.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="owner_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "field {{field.rust_name}}"
            );
            {% if field.owner_write %}
            assert_eq!(
                payload.{{field.rust_name}},
                added.{{field.rust_name}},
                "create result field {{field.rust_name}}"
            );
            {% endif %}
            {%- endfor %}
            assert_eq!(result["_permission"], "owner");

            // Check that we don't return any fields which are supposed to be omitted.
            {% for field in fields | filter (attribute="owner_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }

        let results = user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        for result in results {
            let (payload, added) = added_objects.iter().find(|i| i.1.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="user_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "list result field {{field.rust_name}}"
            );
            {%- endfor %}
            assert_eq!(result["_permission"], "write");

            {% for child in children %}
            {% if child.relationship.populate_on_list == "id" %}
                {% if child.write_payload_field_name %}
                let ids = payload.{{child.write_payload_field_name}}.as_ref().map(|v| v.iter().map(|o| o.id).collect::<Vec<_>>()).unwrap_or_default();
                let ids = serde_json::to_value(&ids).unwrap();
                {% else %}
                let ids = serde_json::json!([]);
                {% endif %}
                assert_eq!(
                    result["{{child.list_sql_field_name}}"],
                    ids,
                    "field {{child.list_sql_field_name}}"
                );
            {% elif child.relationship.populate_on_list == "data" %}
                assert_eq!(
                    result["{{child.list_sql_field_name}}"],
                    {% if child.write_payload_field_name %}
                    serde_json::to_value(&payload.{{child.write_payload_field_name}}).unwrap(),
                    {% else %}
                    serde_json::json!([]),
                    {% endif %}
                    "field {{child.list_sql_field_name}}"
                );
            {% elif chil %}
                // Check all the possibilities for a child field being populated
                {% for f in child.possible_child_field_names -%}
                assert!(result.get("{{f}}").is_none());
                {%- endfor %}
            {% endif %}
            {% endfor %}

            // Check that we don't return any fields which are supposed to be omitted.
            {% for field in fields | filter (attribute="user_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }


        let response = no_roles_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }

    #[sqlx::test]
    async fn list_fetch_specific_ids(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = user
            .client
            .get("{{url_path}}")
            .query(&[
                ("id", added_objects[0].1.id),
                ("id", added_objects[2].1.id),
            ])
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        assert_eq!(results.len(), 2);
        assert!(results.iter().any(|o| o["id"] == added_objects[0].1.id.to_string()));
        assert!(results.iter().any(|o| o["id"] == added_objects[2].1.id.to_string()));
    }

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_order_by(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_paginated(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_filters(_pool: sqlx::PgPool) {}
    {% endif %}

    {% if endpoints.get %}
    #[sqlx::test]
    async fn get_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let (payload, added) = &added_objects[1];
        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "get result field {{field.rust_name}}"
        );
        {% if field.owner_write %}
        assert_eq!(
            added.{{field.rust_name}},
            payload.{{field.rust_name}},
            "create result field {{field.rust_name}}"
        );
        {% endif %}
        {%- endfor %}
        assert_eq!(result["_permission"], "owner");

        {% for child in children %}
        {% if child.relationship.populate_on_get == "id" %}
            {% if child.write_payload_field_name %}
            let ids = payload.{{child.write_payload_field_name}}.as_ref().map(|v| v.iter().map(|o| o.id).collect::<Vec<_>>()).unwrap_or_default();
            let ids = serde_json::to_value(&ids).unwrap();
            {%- else %}
            let ids = serde_json::json!([]);
            {%- endif %}
            assert_eq!(
                result["{{child.get_sql_field_name}}"],
                ids,
                "field {{child.get_sql_field_name}}"
            );
        {% elif child.relationship.populate_on_get == "data" %}
            assert_eq!(
                result["{{child.get_sql_field_name}}"],
                {% if child.write_payload_field_name %}
                serde_json::to_value(&payload.{{child.write_payload_field_name}}).unwrap(),
                {% else %}
                serde_json::json!([]),
                {% endif %}
                "field {{child.get_sql_field_name}}"
            );
        {% else %}
            // Check all the possibilities for a child field being populated
            {% for f in child.possible_child_field_names -%}
            assert!(result.get("{{f}}").is_none());
            {%- endfor %}
        {% endif %}
        {% endfor %}

        // Check that we don't return any fields which are supposed to be omitted.
        {% for field in fields | filter (attribute="owner_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let result = user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let (payload, added) = &added_objects[1];
        {% for field in fields | filter (attribute="user_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "get result field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(result["_permission"], "write");

        // Check that we don't return any fields which are supposed to be omitted.
        {% for field in fields | filter (attribute="user_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let response = no_roles_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.update %}
    #[sqlx::test]
    async fn update_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let update_payload = make_update_payload(20);
        admin_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .json(&update_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let updated: serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_write", value=true) -%}
        assert_eq!(
            updated["{{field.rust_name}}"],
            serde_json::to_value(&update_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(updated["_permission"], "owner");

        // TODO Test that owner can not write fields which are not writable by anyone.
        // TODO Test that user can not update fields which are writable by owner but not user

        // Make sure that no other objects were updated
        let non_updated : serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            non_updated["{{field.rust_name}}"],
            serde_json::to_value(&added_objects[0].1.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(non_updated["_permission"], "owner");

        let response = no_roles_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .json(&update_payload)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.create %}
    #[sqlx::test]
    async fn create_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let create_payload = make_create_payload(10);
        let created_result : serde_json::Value = admin_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();


        {% for field in fields | filter (attribute="owner_write", value=true) -%}
        assert_eq!(
            created_result["{{field.rust_name}}"],
            serde_json::to_value(&create_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}} from create response"
        );
        {%- endfor %}
        assert_eq!(created_result["_permission"], "owner");

        let created_id = created_result["id"].as_str().unwrap();
        let get_result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", created_id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            get_result["{{field.rust_name}}"],
            created_result["{{field.rust_name}}"],
            "field {{field.rust_name}} from get response"
        );
        {%- endfor %}
        assert_eq!(get_result["_permission"], "owner");

        let response = no_roles_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.delete %}
    #[sqlx::test]
    async fn delete_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        admin_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].1.id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::NOT_FOUND);

        // Delete should not happen without permissions
        let response = no_roles_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);

        // Make sure other objects still exist
        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].1.id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::OK);
    }
    {% endif %}
}
{% endif %}{# if has_any_endpoints #}
