#![allow(unused_imports, dead_code)]
use axum::{extract::{State, Path, Query}, http::StatusCode, response::IntoResponse, routing};
use axum_jsonschema::Json;
use axum_extra::extract::Query;
use error_stack::ResultExt;
use filigree::extract::FormOrJson;

use crate::{Error, auth::{Authed, has_any_permission}, server::ServerState};
{% for child in children %}
use crate::models::{{c.module}}::{{c.object_id}};
{% endfor %}

use super::{queries, types::*, {{id_type}}, CREATE_PERMISSION, OWNER_PERMISSION, READ_PERMISSION, WRITE_PERMISSION };

async fn get(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_get %}
    let object = queries::get_populated(&state.db, &auth, id).await?;
    {% else %}
    let object = queries::get(&state.db, &auth, id).await?;
    {% endif %}
    Ok(Json(object))
}

async fn list(
    State(state): State<ServerState>,
    auth: Authed,
    Query(qs): Query<queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {
    {% if can_populate_list %}
    let results = queries::list_populated(&state.db, &auth, &qs).await?;
    {% else %}
    let results = queries::list(&state.db, &auth, &qs).await?;
    {% endif %}
    Ok(Json(results))
}

async fn create(
    State(state): State<ServerState>,
    auth: Authed,
    FormOrJson(payload): FormOrJson<{{ struct_base }}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    let mut tx = state.db.begin().await.change_context(Error::Db)?;
    let result = queries::create(&mut *tx, &auth, &payload).await?;

    {% for c in children %}
        {% if c.relationship.many %}
        let has_children = !payload.{{c.write_payload_field_name}}.is_empty();
        {% else %}
        let has_children = payload.{{c.write_payload_field_name}}.is_some();
        {% endif %}

        if has_children {
            for child in payload.{{c.write_payload_field_name}}.iter_mut() {
                child.id = Some({{c.object_id}}::new());
                child.{{c.parent_field}} = Some(result.id);
            }

            crate::models::{{c.module}}::update_with_parent(&mut *tx, &auth, true, result.id, &payload.{{c.write_payload_field_name}}).await?;
        }
    {% endfor %}

    tx.commit().await.change_context(Error::Db)?;
    Ok((StatusCode::CREATED, Json(result)))
}

async fn update(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>,
    FormOrJson(payload): FormOrJson<{{ struct_base }}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    let updated = queries::update(&mut *tx, &auth, id, &payload).await?;
    if !updated {
        return Ok(StatusCode::NOT_FOUND);
    }

    {% for c in children %}
    if let Some(children) = payload.{{c.rust_name}} {
        crate::models::{{c.module}}::queries::update_with_parent(&mut *tx, &auth, is_owner, id, &children).await?;
    }
    {% endfor %}

    tx.commit().await.change_context(Error::Db)?;
    Ok(StatusCode::OK)
}

async fn delete(
    State(state): State<ServerState>,
    auth: Authed,
    Path(id): Path<{{ id_type }}>
    ) -> Result<impl IntoResponse, Error> {

    let mut tx = state.db.begin().await.change_context(Error::Db)?;

    let deleted = queries::delete(&mut *tx, &auth, id).await?;

    if !deleted {
        return Ok(StatusCode::NOT_FOUND);
    }

    {% for c in children %}
        crate::models::{{c.module}}::queries::delete_all_children_of_parent(&mut *tx, &auth, id).await?;
    {% endfor %}

    tx.commit().await.change_context(Error::Db)?;
    Ok(StatusCode::OK)
}

{% for c in children %}

async fn list_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    Query(mut qs): Query<crate::models::{{c.module}}::queries::ListQueryFilters>,
    ) -> Result<impl IntoResponse, Error> {

    qs.{{parent_field}} = Some(parent_id);

    let object = crate::models::{{c.module}}::queries::list(
        &state.db,
        &auth,
        &qs
        ).await?;

    {% if not c.relationship.many %}
    let object = object
        .get(0)
        .ok_or(Error::NotFound("{{c.relationship.model}}"))?;
    {% endif %}

    Ok(Json(object))
}


{% if c.relationship.many %}
async fn create_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    FormOrJson(payload): FormOrJson<{{c.struct_base}}CreatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    payload.{{c.parent_field}} = Some(parent_id);

    let result = crate::models::{{c.module_name}}::queries::create(
        &state.db,
        &auth,
        &payload
    ).await?;


    Ok(Json(result))
}

async fn update_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    FormOrJson(payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {

    payload.id = Some(child_id);
    payload.{{c.parent_field}} = Some(parent_id);

    let result = crate::models::{{c.module}}::queries::update_one_with_parent(
        &state.db,
        &auth,
        true, // TODO get the right value here
        parent_id,
        child_id,
        &payload).await?;

    Ok(Json(result))
}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path((parent_id, child_id)): Path<({{id_type}}, {{c.object_id}})>,
    ) -> Result<impl IntoResponse, Error> {

    crate::models::{{c.module}}::queries::delete_with_parent(
        &state.db,
        &auth,
        parent_id,
        child_id,
    ).await?;

    Ok(StatusCode::OK)
}

{% else %}

async fn upsert_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    FormOrJson(payload): FormOrJson<{{c.struct_base}}UpdatePayload>,
    ) -> Result<impl IntoResponse, Error> {
    payload.{{c.parent_field}} = Some(parent_id);

    let result = crate::models::{{c.module}}::queries::update_with_parent(
        &state.db,
        &auth,
        true, // TODO get the right value here
        parent_id,,
        &Some(payload).await?;
    Ok(Json(result))
}

async fn delete_child_{{c.module}}(
    State(state): State<ServerState>,
    auth: Authed,
    Path(parent_id): Path<{{id_type}}>,
    ) -> Result<impl IntoResponse, Error> {

    crate::models::{{c.module}}::queries::delete_by_parent(
        &state.db,
        &auth,
        parent_id).await?;

    Ok(StatusCode::OK)
}
{% endif %}

{% endfor %}


pub fn create_routes() -> axum::Router<ServerState> {
    axum::Router::new()
        {% if endpoints.list %}.route("/{{ url_path }}",
            routing::get(list)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.get %}.route("/{{ url_path }}/:id",
            routing::get(get)
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.create %}.route("/{{ url_path }}",
            routing::post(create)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.update %}.route("/{{ url_path }}/:id",
            routing::put(update)
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"])))
        {% endif %}
        {% if endpoints.delete %}.route("/{{ url_path }}/:id",
            routing::delete(delete)
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"])))
        {% endif %}

    {% for c in children %}
    {% if endpoints.list %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::get(list_child_{{c.module}})
                .route_layer(has_any_permission(vec![READ_PERMISSION, "org_admin"])))
    {% endif %}

    {% if endpoints.create %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            {% if c.relationship.many %}
            routing::post(create_child_{{c.module}})
            {% else %}
            routing::post(upsert_child_{{c.module}})
            {% endif %}
                .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
            )
    {% endif %}

    {% if endpoints.update %}
        {% if c.relationship.many %}
        .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
            routing::post(update_child_{{c.module}})
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
            routing::post(upsert_child_{{c.module}})
        {% endif %}
                .route_layer(has_any_permission(vec![WRITE_PERMISSION, OWNER_PERMISSION, "org_admin"]))
            )
    {% endif %}

    {% if endpoints.delete %}
        {% if c.relationship.many %}
        .route("/{{url_path}}/:id/{{c.url_path}}/:child_id",
        {% else %}
        .route("/{{url_path}}/:id/{{c.url_path}}",
        {% endif %}
        routing::delete(delete_child_{{c.module}})
            .route_layer(has_any_permission(vec![CREATE_PERMISSION, "org_admin"]))
        )

    {% endif %}
    {% endfor %}
}

#[cfg(test)]
mod test {
    use filigree::testing::ResponseExt;
    use futures::{StreamExt, TryStreamExt};
    use tracing::{event, Level};

    use super::*;
    use crate::{
        {% if model_name != "Organization" %}
        models::organization::OrganizationId,
        {% endif %}
        tests::{start_app, BootstrappedData},
    };

    {% macro payload_field_value(field) %}
        {%- if field.base_type == "text" -%}
            format!("Test object {i}")
        {%- elif field.base_type in ["int", "bigint", "float"] -%}
            i as {{field.base_rust_type}}
        {%- elif field.base_type == "boolean" -%}
           i % 2 == 0
        {%- elif field.base_type == "timestamp" -%}
            chrono::Utc::now()
        {%- elif field.base_rust_type == "serde_json::Value" -%}
            serde_json::json!({ "key": i })
        {%- elif field.is_custom_rust_type -%}
            <{{field.base_rust_type}} as Default>::default()
        {%- elif field.base_type == "uuid" -%}
            uuid::Uuid::new_v4()
        {%- else -%}
            <{{field.base_rust_type}} as Default>::default()
        {%- endif -%}
    {% endmacro %}

    fn make_create_payload(i: usize) -> {{struct_base}}CreatePayload {
        {{struct_base}}CreatePayload {
            {% for field in fields | filter(attribute="owner_write", value=true) -%}
            {{field.rust_name}}:
                {%- if field.nullable -%}(i > 1).then(|| {%endif%}
                    {{ self::payload_field_value(field=field) }}
                {%- if field.nullable -%}){%endif%},
            {%- endfor %}
        }
    }

    async fn setup_test_objects(
        db: &sqlx::PgPool,
        organization_id: OrganizationId,
        count: usize,
    ) -> Vec<{{struct_base}}> {
        futures::stream::iter(1..=count)
            .map(Ok)
            .and_then(|i| async move {
                let id = {{id_type}}::new();
                event!(Level::INFO, %id, "Creating test object {}", i);
                super::queries::create_raw(
                    db,
                    id,
                    organization_id,
                    &make_create_payload(i),
                )
                .await
            })
            .try_collect::<Vec<_>>()
            .await
            .unwrap()
    }

    {% if endpoints.list %}
    #[sqlx::test]
    async fn list_objects(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                user,
                {% if model_name == "Role" %}
                admin_role,
                user_role,
                {% endif %}
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = admin_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {# Filter out fixed objects that were created in the bootstrapping process, since it makes testing
        easier. #}
        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        assert_eq!(results.len(), added_objects.len());

        for result in results {
            let added = added_objects.iter().find(|i| i.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="owner_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "field {{field.rust_name}}"
            );
            {%- endfor %}
            assert_eq!(result["_permission"], "owner");

            // Check that we don't return any fields which are supposed to be omitted.
            {% for field in fields | filter (attribute="owner_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }

        let results = user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        {% if model_name == "Role" %}
        let fixed_roles = [
            admin_role.to_string(),
            user_role.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_roles.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% elif model_name == "User" %}
        let fixed_users = [
            admin_user.user_id.to_string(),
            user.user_id.to_string(),
            no_roles_user.user_id.to_string(),
        ];
        let results = results.into_iter().filter(|value| {
            !fixed_users.iter().any(|i| i == value["id"].as_str().unwrap())
        }).collect::<Vec<_>>();
        {% endif %}

        for result in results {
            let added = added_objects.iter().find(|i| i.id.to_string() == result["id"].as_str().unwrap())
                .expect("Returned object did not match any of the added objects");
            {% for field in fields | filter (attribute="user_read", value=true) -%}
            assert_eq!(
                result["{{field.rust_name}}"],
                serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
                "field {{field.rust_name}}"
            );
            {%- endfor %}
            assert_eq!(result["_permission"], "write");

            // Check that we don't return any fields which are supposed to be omitted.
            {% for field in fields | filter (attribute="user_read", value=false) -%}
            assert_eq!(
                result.get("{{field.rust_name}}"),
                None,
                "field {{field.rust_name}} should be omitted"
            );
            {%- endfor %}
        }


        let response = no_roles_user
            .client
            .get("{{url_path}}")
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }

    #[sqlx::test]
    async fn list_fetch_specific_ids(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 3).await;

        let results = user
            .client
            .get("{{url_path}}")
            .query(&[
                ("id", added_objects[0].id),
                ("id", added_objects[2].id),
            ])
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<Vec<serde_json::Value>>()
            .await
            .unwrap();

        assert_eq!(results.len(), 2);
        assert!(results.iter().any(|o| o["id"] == added_objects[0].id.to_string()));
        assert!(results.iter().any(|o| o["id"] == added_objects[2].id.to_string()));
    }

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_order_by(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_paginated(_pool: sqlx::PgPool) {}

    #[sqlx::test]
    #[ignore = "todo"]
    async fn list_filters(_pool: sqlx::PgPool) {}
    {% endif %}

    {% if endpoints.get %}
    #[sqlx::test]
    async fn get_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let added = &added_objects[1];
        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(result["_permission"], "owner");

        // Check that we don't return any fields which are supposed to be omitted.
        {% for field in fields | filter (attribute="owner_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let result = user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        let added = &added_objects[1];
        {% for field in fields | filter (attribute="user_read", value=true) -%}
        assert_eq!(
            result["{{field.rust_name}}"],
            serde_json::to_value(&added.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(result["_permission"], "write");

        // Check that we don't return any fields which are supposed to be omitted.
        {% for field in fields | filter (attribute="user_read", value=false) -%}
        assert_eq!(
            result.get("{{field.rust_name}}"),
            None,
            "field {{field.rust_name}} should be omitted"
        );
        {%- endfor %}

        let response = no_roles_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.update %}
    #[sqlx::test]
    async fn update_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        let i = 20;
        let update_payload = {{struct_base}}UpdatePayload {
            {% set uwc = fields | filter (attribute="user_write", value=true) | length -%}
            {% for field in fields | filter (attribute="owner_write", value=true) -%}
            {% set uopt = uwc > 0 and not field.user_write %}
            {% set nullable = field.nullable or uopt %}
            {{field.rust_name}}:
                {%- if nullable %} Some({%- endif -%}
                {{ self::payload_field_value(field=field) }}
                {%- if nullable %}){% endif -%},
            {%- endfor %}
        };

        admin_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].id))
            .json(&update_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let updated: serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_write", value=true) -%}
        assert_eq!(
            updated["{{field.rust_name}}"],
            serde_json::to_value(&update_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(updated["_permission"], "owner");

        // TODO Test that owner can not write fields which are not writable by anyone.
        // TODO Test that user can not update fields which are writable by owner but not user

        // Make sure that no other objects were updated
        let non_updated : serde_json::Value = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            non_updated["{{field.rust_name}}"],
            serde_json::to_value(&added_objects[0].{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}}"
        );
        {%- endfor %}
        assert_eq!(non_updated["_permission"], "owner");

        let response = no_roles_user
            .client
            .put(&format!("{{url_path}}/{}", added_objects[1].id))
            .json(&update_payload)
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.create %}
    #[sqlx::test]
    async fn create_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let create_payload = make_create_payload(10);
        let created_result : serde_json::Value = admin_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();


        {% for field in fields | filter (attribute="owner_write", value=true) -%}
        assert_eq!(
            created_result["{{field.rust_name}}"],
            serde_json::to_value(&create_payload.{{field.rust_name}}).unwrap(),
            "field {{field.rust_name}} from create response"
        );
        {%- endfor %}
        assert_eq!(created_result["_permission"], "owner");

        let created_id = created_result["id"].as_str().unwrap();
        let get_result = admin_user
            .client
            .get(&format!("{{url_path}}/{}", created_id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap()
            .json::<serde_json::Value>()
            .await
            .unwrap();

        {% for field in fields | filter (attribute="owner_read", value=true) -%}
        assert_eq!(
            get_result["{{field.rust_name}}"],
            created_result["{{field.rust_name}}"],
            "field {{field.rust_name}} from get response"
        );
        {%- endfor %}
        assert_eq!(get_result["_permission"], "owner");

        let response = no_roles_user
            .client
            .post("{{url_path}}")
            .json(&create_payload)
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);
    }
    {% endif %}

    {% if endpoints.delete %}
    #[sqlx::test]
    async fn delete_object(pool: sqlx::PgPool) {
        let (
            _app,
            BootstrappedData {
                organization,
                admin_user,
                no_roles_user,
                ..
            },
        ) = start_app(pool.clone()).await;

        let added_objects = setup_test_objects(&pool, organization.id, 2).await;

        admin_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap()
            .log_error()
            .await
            .unwrap();

        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[1].id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::NOT_FOUND);

        // Delete should not happen without permissions
        let response = no_roles_user
            .client
            .delete(&format!("{{url_path}}/{}", added_objects[0].id))
            .send()
            .await
            .unwrap();

        assert_eq!(response.status(), reqwest::StatusCode::FORBIDDEN);

        // Make sure other objects still exist
        let response = admin_user
            .client
            .get(&format!("{{url_path}}/{}", added_objects[0].id))
            .send()
            .await
            .unwrap();
        assert_eq!(response.status(), reqwest::StatusCode::OK);
    }
    {% endif %}
}
