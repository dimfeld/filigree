mod base_models;
pub mod field;
mod generate_endpoints;
mod generate_sql;
pub mod generator;

use std::borrow::Cow;

use convert_case::{Case, Casing};
use serde::{Deserialize, Serialize};

use self::field::{Access, DeleteBehavior, ModelField, ModelFieldReference, SqlType};

#[derive(Deserialize, Debug)]
pub struct Model {
    pub name: String,
    /// The plural of [name], if not generated by adding the letter 's' to the end.
    #[serde(default)]
    pub plural: Option<String>,
    /// A prefix of a few characters for the ID of this type.
    pub id_prefix: String,
    pub fields: Vec<ModelField>,
    /// If true, generate API endpoints for this model.
    pub endpoints: bool,

    /// Extra SQL to place after the column definitions inside the `CREATE TABLE` statement.
    #[serde(default)]
    pub extra_create_table_sql: String,

    /// If true, this model does not have a team_id.
    /// This mostly applies to the team object itself but may be useful for other things.
    #[serde(default)]
    pub global: bool,

    /// SQL to create indexes on the field
    #[serde(default)]
    pub indexes: Vec<String>,
    // TODO ability to define extra permissions
    // TODO ability to define extra operations that update specific things and require specific
    // permissions.
}

impl Model {
    pub fn module_name(&self) -> String {
        self.name.to_case(Case::Snake)
    }

    pub fn table(&self) -> String {
        self.plural().to_case(Case::Snake)
    }

    pub fn object_id_type(&self) -> String {
        format!("{}Id", self.id_prefix.to_case(Case::Camel))
    }

    pub fn plural(&self) -> Cow<str> {
        self.plural
            .as_deref()
            .map(Cow::Borrowed)
            .unwrap_or_else(|| Cow::Owned(format!("{}s", self.name)))
    }

    pub fn all_fields(&self) -> impl Iterator<Item = (bool, Cow<ModelField>)> {
        self.standard_fields()
            .map(|field| (true, Cow::Owned(field)))
            .chain(
                self.fields
                    .iter()
                    .map(|field| (false, Cow::Borrowed(field))),
            )
    }

    /// The fields that apply to every object
    fn standard_fields(&self) -> impl Iterator<Item = ModelField> {
        let team_field = if self.global {
            None
        } else {
            Some(ModelField {
                name: "team_id".to_string(),
                typ: SqlType::Uuid,
                rust_type: Some("TeamId".to_string()),
                nullable: false,
                unique: false,
                indexed: true,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                default: String::new(),
                references: Some(ModelFieldReference::new(
                    "teams",
                    "id",
                    DeleteBehavior::Cascade,
                )),
            })
        };

        [
            Some(ModelField {
                name: "id".to_string(),
                typ: SqlType::Uuid,
                rust_type: Some(self.object_id_type()),
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: "primary key".to_string(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: String::new(),
            }),
            team_field,
            Some(ModelField {
                name: "updated_at".to_string(),
                typ: SqlType::Timestamp,
                rust_type: None,
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: "now()".to_string(),
            }),
            Some(ModelField {
                name: "created_at".to_string(),
                typ: SqlType::Timestamp,
                rust_type: None,
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: "now()".to_string(),
            }),
        ]
        .into_iter()
        .flatten()
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum SqlDialect {
    Postgresql,
    SQLite,
}
