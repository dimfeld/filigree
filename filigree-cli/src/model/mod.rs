mod base_models;
mod generate_endpoints;
mod generate_sql;

use std::{borrow::Cow, ops::Deref, path::Path};

use convert_case::{Case, Casing};
use error_stack::{Report, ResultExt};
use serde::{Deserialize, Serialize};
use serde_json::json;
use tera::Tera;

use crate::{templates::get_tera, Error};

#[derive(Deserialize, Debug)]
pub struct Model {
    pub name: String,
    /// The plural of [name], if not generated by adding the letter 's' to the end.
    #[serde(default)]
    pub plural: Option<String>,
    /// A prefix of a few characters for the ID of this type.
    pub id_prefix: String,
    pub fields: Vec<ModelField>,
    /// If true, generate API endpoints for this model.
    pub endpoints: bool,

    /// Extra SQL to place after the column definitions inside the `CREATE TABLE` statement.
    #[serde(default)]
    pub extra_create_table_sql: String,

    /// If true, this model does not have a team_id.
    /// This mostly applies to the team object itself but may be useful for other things.
    #[serde(default)]
    pub global: bool,

    /// SQL to create indexes on the field
    #[serde(default)]
    pub indexes: Vec<String>,
    // TODO ability to define extra permissions
    // TODO ability to define extra operations that update specific things and require specific
    // permissions.
}

impl Model {
    pub fn module_name(&self) -> String {
        self.name.to_case(Case::Snake)
    }

    pub fn table(&self) -> String {
        self.plural().to_case(Case::Snake)
    }

    pub fn object_id_type(&self) -> String {
        format!("{}Id", self.id_prefix.to_case(Case::Camel))
    }

    pub fn plural(&self) -> Cow<str> {
        self.plural
            .as_deref()
            .map(Cow::Borrowed)
            .unwrap_or_else(|| Cow::Owned(format!("{}s", self.name)))
    }

    pub fn all_fields(&self) -> impl Iterator<Item = (bool, Cow<ModelField>)> {
        self.standard_fields()
            .map(|field| (true, Cow::Owned(field)))
            .chain(
                self.fields
                    .iter()
                    .map(|field| (false, Cow::Borrowed(field))),
            )
    }

    /// The fields that apply to every object
    fn standard_fields(&self) -> impl Iterator<Item = ModelField> {
        let team_field = if self.global {
            None
        } else {
            Some(ModelField {
                name: "team_id".to_string(),
                typ: SqlType::Uuid,
                rust_type: Some("TeamId".to_string()),
                nullable: false,
                unique: false,
                indexed: true,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                default: String::new(),
                references: Some(ModelFieldReference::new(
                    "teams",
                    "id",
                    DeleteBehavior::Cascade,
                )),
            })
        };

        [
            Some(ModelField {
                name: "id".to_string(),
                typ: SqlType::Uuid,
                rust_type: Some(self.object_id_type()),
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: "primary key".to_string(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: String::new(),
            }),
            team_field,
            Some(ModelField {
                name: "updated_at".to_string(),
                typ: SqlType::Timestamp,
                rust_type: None,
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: "now()".to_string(),
            }),
            Some(ModelField {
                name: "created_at".to_string(),
                typ: SqlType::Timestamp,
                rust_type: None,
                nullable: false,
                unique: false,
                indexed: false,
                extra_sql_modifiers: String::new(),
                user_access: Access::Read,
                owner_access: Access::Read,
                references: None,
                default: "now()".to_string(),
            }),
        ]
        .into_iter()
        .flatten()
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModelField {
    /// The name of the field
    pub name: String,

    /// The SQL type for this field.
    #[serde(rename = "type")]
    pub typ: SqlType,
    /// The Rust type for this field. If omitted, the type will be inferred from the SQL
    /// type.
    pub rust_type: Option<String>,

    #[serde(default)]
    pub nullable: bool,
    #[serde(default)]
    pub unique: bool,

    #[serde(default)]
    pub extra_sql_modifiers: String,

    /// Define how callers to the API can access this field
    #[serde(default)]
    pub user_access: Access,

    /// Define how owners on this object can access the field
    /// Allthough this defaults to [Access::None], it is effectively always
    /// at least as permissive as [user_access].
    #[serde(default)]
    pub owner_access: Access,

    /// The default value of this field, as a SQL expression
    #[serde(default)]
    pub default: String,

    /// If true, create an index on this field.
    /// More exotic index types can be specified using [Model#indexes].
    #[serde(default)]
    pub indexed: bool,

    pub references: Option<ModelFieldReference>,
}

impl ModelField {
    pub fn rust_field_name(&self) -> String {
        let base_name = match self.name.as_str() {
            "type" => "typ",
            _ => &self.name,
        };

        base_name.to_case(Case::Snake)
    }

    pub fn sql_field_name(&self) -> String {
        self.name.to_case(Case::Snake)
    }

    pub fn qualified_sql_field_name(&self) -> String {
        let field_name = self.sql_field_name();
        if let Some(rust_type) = &self.rust_type {
            format!("{field_name}: {rust_type}")
        } else {
            field_name
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModelFieldReference {
    table: String,
    field: String,
    delete_behavior: DeleteBehavior,
}

impl ModelFieldReference {
    pub fn new(
        table: impl Into<String>,
        field: impl Into<String>,
        delete_behavior: DeleteBehavior,
    ) -> Self {
        Self {
            table: table.into(),
            field: field.into(),
            delete_behavior,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "snake_case")]
pub enum DeleteBehavior {
    Ignore,
    Restrict,
    Cascade,
    SetNull,
    SetDefault,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum SqlDialect {
    Postgresql,
    SQLite,
}

#[derive(Serialize, Deserialize, Debug, Copy, Clone)]
#[serde(rename_all = "lowercase")]
pub enum SqlType {
    Text,
    Int,
    BigInt,
    Uuid,
    Float,
    Boolean,
    Json,
    Timestamp,
}

impl SqlType {
    pub fn to_rust_type(&self) -> &'static str {
        match self {
            SqlType::Text => "String",
            SqlType::Int => "i64",
            SqlType::BigInt => "i64",
            SqlType::Float => "f64",
            SqlType::Boolean => "bool",
            SqlType::Json => "serde_json::Value",
            SqlType::Timestamp => "chrono::DateTime<chrono::Utc>",
            SqlType::Uuid => "uuid::Uuid",
        }
    }

    pub fn to_sql_type(&self, dialect: SqlDialect) -> &'static str {
        match (self, dialect) {
            (SqlType::Text, _) => "TEXT",
            (SqlType::Int, _) => "INTEGER",
            (SqlType::BigInt, SqlDialect::Postgresql) => "BIGINT",
            (SqlType::BigInt, SqlDialect::SQLite) => "INTEGER",
            (SqlType::Float, _) => "DOUBLE PRECISION",
            (SqlType::Boolean, SqlDialect::Postgresql) => "BOOLEAN",
            (SqlType::Boolean, SqlDialect::SQLite) => "INTEGER",
            (SqlType::Json, SqlDialect::Postgresql) => "JSONB",
            (SqlType::Json, SqlDialect::SQLite) => "JSON",
            (SqlType::Timestamp, SqlDialect::Postgresql) => "TIMESTAMPTZ",
            (SqlType::Timestamp, SqlDialect::SQLite) => "INTEGER",
            (SqlType::Uuid, SqlDialect::Postgresql) => "UUID",
            (SqlType::Uuid, SqlDialect::SQLite) => "BLOB",
        }
    }
}

/// Define how callers to the API can access this field
#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "snake_case")]
pub enum Access {
    /// No access
    None,
    /// Only read
    Read,
    /// Only write
    Write,
    /// Read and write
    ReadWrite,
}

impl Default for Access {
    fn default() -> Self {
        Self::None
    }
}

impl Access {
    fn can_read(&self) -> bool {
        matches!(self, Self::Read | Self::ReadWrite)
    }

    fn can_write(&self) -> bool {
        matches!(self, Self::Write | Self::ReadWrite)
    }
}

pub struct ModelGenerator<'a> {
    model: Model,
    context: tera::Context,
    base_path: &'a Path,
    tera: &'a Tera,
}

impl<'a> ModelGenerator<'a> {
    pub fn new(base_path: &'a Path, model: Model, dialect: SqlDialect) -> Self {
        Self {
            context: Self::create_template_context(&model, dialect),
            model,
            base_path,
            tera: get_tera(),
        }
    }

    fn create_template_context(model: &Model, dialect: SqlDialect) -> tera::Context {
        let mut context = tera::Context::new();
        context.insert("table", &model.table());
        context.insert("indexes", &model.indexes);

        context.insert("global", &model.global);
        context.insert("owner_permission", &format!("{}::owner", model.id_prefix));
        context.insert("read_permission", &format!("{}::read", model.name));
        context.insert("write_permission", &format!("{}::write", model.id_prefix));
        context.insert("extra_create_table_sql", &model.extra_create_table_sql);
        context.insert("sql_dialect", &dialect);

        let fields = model
            .all_fields()
            .map(|(fixed, field)| {
                json!({
                    "sql_name": field.sql_field_name(),
                    "sql_full_name": field.qualified_sql_field_name(),
                    "sql_type": field.typ.to_sql_type(dialect),
                    "rust_name": field.rust_field_name(),
                    "rust_type": field.rust_type.clone().unwrap_or_else(|| field.typ.to_rust_type().to_string()),
                    "default": field.default,
                    "nullable": field.nullable,
                    "unique": field.unique,
                    "extra_sql_modifiers": field.extra_sql_modifiers,
                    "user_read": field.user_access.can_read(),
                    "user_write": !fixed && field.user_access.can_write(),
                    "owner_read": field.owner_access.can_read() || field.user_access.can_read(),
                    "owner_write": !fixed && (field.owner_access.can_write() || field.user_access.can_write()),
                    "updatable": !fixed,
                })
            })
            .collect::<Vec<_>>();

        context.insert("fields", &fields);
        context
    }

    fn render_to_file(&self, template_name: &str, filename: &str) -> Result<(), Report<Error>> {
        let path = self.base_path.join(self.model.module_name()).join(filename);
        let output = self
            .tera
            .render("select_one.sql.tera", &self.context)
            .change_context(Error::Render)
            .attach_printable_lazy(|| format!("Model {}", self.model.name))
            .attach_printable_lazy(|| format!("Template {}", template_name))?;

        std::fs::write(&path, output)
            .change_context(Error::WriteFile)
            .attach_printable_lazy(|| path.display().to_string())?;
        Ok(())
    }
}

impl Deref for ModelGenerator<'_> {
    type Target = Model;

    fn deref(&self) -> &Self::Target {
        &self.model
    }
}
