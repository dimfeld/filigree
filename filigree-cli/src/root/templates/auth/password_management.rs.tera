use axum::{
    extract::{Host, Query, State},
    response::{IntoResponse, Redirect},
    Json,
};
use error_stack::ResultExt;
use filigree::auth::{password::create_reset_token, AuthError, EmailBody};
use serde::{Deserialize, Serialize};
use tower_cookies::Cookies;
use uuid::Uuid;

use crate::{server::ServerState, Error};

pub async fn start_password_reset(
    State(state): State<ServerState>,
    Host(host): Host,
    Json(body): Json<EmailBody>,
) -> Result<impl IntoResponse, Error> {
    let token = create_reset_token(&body.email).await;

    let token = match token {
        Ok(token) => token,
        Err(e) => {
            if e.is_unauthenticated() {
                // Don't do anything if the email was not found, but also don't tell the user that
                // the email doesn't exist.
                return Ok(());
            } else {
                return Err(e.change_context(Error::AuthSubsystem).into());
            }
        }
    };

    let template = crate::emails::PasswordResetRequestTemplate {
        user_name: None,
        url_scheme: state.site_scheme(),
        // TODO validate that the host is in the allowed list
        host,
        email: request.email.clone(),
        token,
    };

    state
        .filigree
        .email
        .send_template(request.email, template)
        .await
        .change_context(Error::AuthSubsystem)?;

    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        auth::tests::extract_token_from_email,
        tests::{start_app, BootstrappedData},
    };

    #[sqlx::test]
    async fn change_password(db: sqlx::PgPool) {
        let (app, BootstrappedData { user, .. }) = start_app(db).await;

        app.client
            .post("auth/request_password_reset")
            .json(EmailBody {
                email: user.email.clone(),
            })
            .send()
            .await
            .unwrap()
            .error_for_status()
            .unwrap();

        let email = app.emails.lock().unwrap().pop().unwrap();
        let token = extract_token_from_email(&email);

        app.client
            .post("auth/update_password")
            .json(UpdatePasswordRequest {
                email: user.email.clone(),
                token,
                password: "a_new_password".to_string(),
                confirm: "a_new_password".to_string(),
            })
            .send()
            .await
            .unwrap()
            .error_for_status()
            .unwrap();

        // Try to log in with the new password
        app.client
            .post("auth/login")
            .json(json!({ "email": user.email, "password": "a_new_password"}))
            .send()
            .await
            .unwrap()
            .error_for_status()
            .unwrap();
    }
}
