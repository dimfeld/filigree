use axum::{
    extract::{Host, Query, State},
    response::{IntoResponse, Redirect},
    Json,
};
use error_stack::{Report, ResultExt};
use filigree::{
    auth::{
        passwordless_email_login::{perform_passwordless_login, setup_passwordless_login},
        AuthError,
    },
    email::templates::EmailTemplate,
};
use serde::Deserialize;
use tower_cookies::Cookies;
use uuid::Uuid;

use crate::{server::ServerState, Error};

#[derive(Debug, Deserialize)]
struct CreatePasswordlessLoginRequestBody {
    email: String,
    redirect_to: Option<String>,
}

pub async fn request_passwordless_login(
    State(state): State<ServerState>,
    Host(host): Host,
    Json(CreatePasswordlessLoginRequestBody { email, redirect_to }): Json<
        CreatePasswordlessLoginRequestBody,
    >,
) -> Result<impl IntoResponse, Error> {
    let token = setup_passwordless_login(&state.filigree, email.clone()).await;

    let token = match token {
        Ok(token) => token,
        Err(e) => {
            if e.current_context().is_unauthenticated() {
                // Don't do anything if the email was not found, but also don't tell the user that
                // the email doesn't exist.
                return Ok(());
            } else {
                return Err(e.change_context(Error::AuthSubsystem).into());
            }
        }
    };

    // TODO better validation against a list of allowed domains
    let redirect_to = if redirect_to
        .as_deref()
        .map(|s| s.contains("//"))
        .unwrap_or(false)
    {
        None
    } else {
        redirect_to
    };

    let template = crate::emails::PasswordlessLoginRequestTemplate {
        // TODO get the user's name in `setup_passwordless_login`, if we have it
        user_name: None,
        // TODO validate that the host is in the allowed list
        base_url: host,
        email: email.clone(),
        redirect_to,
        token,
    };

    state
        .filigree
        .email
        .send_template(email, template)
        .await
        .change_context(Error::AuthSubsystem)?;

    Ok(())
}

#[derive(Debug, Deserialize)]
struct PasswordlessLoginRequestQueryFromEmail {
    email: String,
    token: Uuid,
    redirect_to: Option<String>,
}

pub async fn process_passwordless_login_token(
    State(state): State<ServerState>,
    cookies: Cookies,
    Query(q): Query<PasswordlessLoginRequestQueryFromEmail>,
) -> Result<impl IntoResponse, Redirect> {
    perform_passwordless_login(&state.filigree, &cookies, q.email, q.token)
        .await
        .map_err(|e| {
            if matches!(e.current_context(), AuthError::InvalidToken) {
                Redirect::to("/passwordless_login?error=invalid_token")
            } else {
                // TODO report this error since it won't be passed through the normal middleware
                Redirect::to("/passwordless_login?error=internal")
            }
        })?;

    let mut redirect_path = q.redirect_to.as_deref().unwrap_or("/");
    if redirect_path.contains("//") {
        // Very simple check to prevent redirects to other domains
        // This should actually validate against a whitelist of allowed domains
        redirect_path = "/";
    }

    Ok(Redirect::temporary(redirect_path))
}
