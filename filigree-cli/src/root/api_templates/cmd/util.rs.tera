use clap::{Args, Subcommand};
use error_stack::{Report, ResultExt};
use schemars::schema_for;

use crate::Error;

#[derive(Args, Debug)]
pub struct UtilCommand {
    #[clap(subcommand)]
    pub command: UtilSubcommand,
}

#[derive(Debug, Subcommand)]
pub enum UtilSubcommand {
    HashPassword(HashPasswordCommand),
    SyncTypes,
}

#[derive(Args, Debug)]
pub struct HashPasswordCommand {
    password: String,
}

impl UtilCommand {
    pub async fn handle(self) -> Result<(), Report<Error>> {
        match self.command {
            UtilSubcommand::HashPassword(password) => {
                let hash = filigree::auth::password::new_hash(password.password)
                    .await
                    .change_context(Error::AuthSubsystem)?
                    .0;
                println!("{hash}");
            },
            UtilSubcommand::SyncTypes => sync_types()?,
        }

        Ok(())
    }
}

fn sync_types() -> Result<(), Report<Error>> {
    let schemas = [
        schema_for!(crate::users::users::SelfUser),
        {% for type in shared_types -%}
        schema_for!({{type}}),
        {%- endfor -%}
    ];

    let merged = schemars_zod::merge_schemas(schemas.into_iter());
    let converted = schemars_zod::convert(merged);

    let header = "// This file is autogenerated by the API's `util sync-types` command.
import { z, type ZodTypeAny } from 'zod';

function memoizeOne<T extends ZodTypeAny>(fn: () => T) : () => T {
  let cached: T|undefined;
  return function() {
    if(!cached) {
      cached = fn();
    }
    return cached;
  };
}";

    let types = converted.iter().map(|(_, v)| v.as_str());

    let output = std::iter::once(header)
        .chain(types)
        .collect::<Vec<_>>()
        .join("\n\n");

    let output_path = "../web/src/lib/api_types.ts";
    std::fs::write(output_path, &output).change_context(Error::TypeExport)?;

    Ok(())
}
